/*
!Сводка
Метод map() создаёт новый массив с результатом вызова указанной функции для каждого 
элемента массива.

!Синтаксис
const new_array = arr.map(function callback( currentValue[, index[, array]]) {
    // Возвращает элемент для new_array
}[, thisArg])
*/

/*
!Примеры
Пример: отображение массива чисел на массив квадратных корней
Следующий код берёт массив чисел и создаёт новый массив, содержащий квадратные корни 
чисел из первого массива.

const numbers = [1, 4, 9];
const roots = numbers.map(Math.sqrt);
// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]

!Пример: отображение массива чисел с использованием функции, содержащей аргумент
Следующий код показывает, как работает отображение, когда функция требует один аргумент. 
Аргумент будет автоматически присваиваться каждому элементу массива, когда map проходит 
по оригинальному массиву.

const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);
// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]
*/

//!Функция map заменяет цикл. Просто перебирает массив. 
//! Метод map и filter НЕменяют исходный массив перебирают и выдают результат

// Создаем массив
let a01 = [4, 5, 12, 200, 1, 0, -2];

let b01 = a01.map(function (item, index) {
   console.log(item);
   return item; //перебрал весь массив и вернул
});
console.log(b01);


let c01 = a01.map(function (item, index) {
   console.log(index);
   return index; //вернет индекс элемента 0, 1, 2, 3, 4, .....
});
console.log(c01);

// Стоит задача умножить каждый элемент массива на 5
let b02 = a01.map(function (item, index) {
   console.log(item * 5);
   return item * 5; //перебрал весь массив и вернул
});
console.log(b02);

// Можно упростить запись заменить на стрелочную функцию
let b03 = a01.map((item, index) => {
   console.log(item * 5);
   return item * 5; //перебрал весь массив и вернул
});
console.log(b03);

// Можно еще упростить если только необходимо выводить один return. Удаляем слово return
let b04 = a01.map((item, index) => item * 5) //перебрал весь массив и вернул
console.log(b04);

// Можно еще упростить если используется только один параметр item можно убирать скобки()
let b05 = a01.map(item => item * 5) //перебрал весь массив и вернул
console.log(b05);


//---------------------------------------------------------------------------------------

/*
!Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, 
задаваемую в передаваемой функции.

Интерактивный пример
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]


!Синтаксис
// Стрелочная функция
filter((element) => { ... } )
filter((element, index) => { ... } )
filter((element, index, array) => { ... } )

// Колбэк-функция
filter(callbackFn)
filter(callbackFn, thisArg)

// Встроенная колбэк-функция
filter(function callbackFn(element) { ... })
filter(function callbackFn(element, index) { ... })
filter(function callbackFn(element, index, array){ ... })
filter(function callbackFn(element, index, array) { ... }, thisArg)

!Возвращаемое значение
Вернётся новый массив с элементами, которые прошли проверку. Если ни один элемент не 
прошёл проверку, то будет возвращён пустой массив.

!Параметры
callbackFn
Функция-предикат, которая будет вызвана для проверки каждого элемента массива. 
Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

Принимает три аргумента

element
Текущий обрабатываемый элемент в массиве.

!Возвращаемое значение
Вернётся новый массив с элементами, которые прошли проверку. Если ни один элемент не 
прошёл проверку, то будет возвращён пустой массив.

!Описание
Метод filter() вызывает переданную функцию callback один раз для каждого элемента, 
присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых 
функция callback вернула значение, которое может быть приведено к true. 
Функция callback вызывается только для индексов массива с уже определёнными значениями; 
она не вызывается для индексов, которые были удалены или которым значения никогда 
не присваивались. Элементы массива, не прошедшие проверку функцией callback, 
просто пропускаются и не включаются в новый массив.

Функция callback вызывается с тремя аргументами:

значение элемента;
индекс элемента;
массив, по которому осуществляется проход.

!Примеры
Фильтрация всех маленьких значений
Следующий пример использует filter() для создания отфильтрованного массива, все элементы 
которого больше или равны 10, а все меньшие 10 удалены.

function isBigEnough(value) {
  return value >= 10;
}

let filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// массив filtered теперь содержит [12, 130, 44]
Copy to Clipboard
Найти все простые числа в массиве
Следующий пример возвращает все простые числа в массиве:

const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]
*/
console.log('filter------------------------------------------------------------------filter');

//! в методе filter мы сами решаем что попадет в массив
//! Используем filter если необходимо выбрать элементы больше когогото, больше 0, по условию... Заменяем вместо циклов
//! Отличие от циклов быстрее и короче запись и сразу понятно что хотите сделать. Это просто удобнее чем циклы.
//! Метод map и filter неменяют исходный массив перебирают и выдают результат
// Создаем массив
let a02 = [4, 5, 12, 200, 1, 0, -2];
let d01 = a02.filter(function (item, index) {
   /*
callbackFn
Функция-предикат, которая будет вызвана для проверки каждого элемента массива. 
Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.
   */
   return true; // true вернет весь массив. false вернет пустой массив
});
console.log(d01);


// выведим только четные элементы массива a02
let d02 = a02.filter(function (item, index) {
   if (item % 2 == 0) {
      return true;
   }

   // else {            // else можно неписать 
   //    return false;
   // }

});
console.log(d02);

// выведим элементы больше 0
let d03 = a02.filter(function (item, index) {
   if (item > 0) {
      return true;
   }
});
console.log(d03);

//! если хотим перебрать только числа включаем typeof
let a03 = [41, 51, 'aaa', 121, true, 2001, 'bbb', 11, false, 0, -21];
console.log(a03);
let d04 = a03.filter(function (item, index) {
   if (typeof item == 'number') {
      return true;
   }
})
console.log(d04);



//---------------------------------------------------------------------------------------

// для решения задач используйте эти переменные
let a1_res = [],
   a2_res = [],
   a3_res = [],
   a4_res = [],
   b1_res = [],
   b6_res = [],
   b7_res = [],
   b8_res = [],
   b9_num = [],
   b9_string = [],
   b10_res;

// Task 1 ============================================
/* Дан массив a1 = [4, 5, 6, 7, 12, 34, 56, 78, 90, 11] - с помощью map переберите 
массив и создайте новый массив a1_res куда добавьте элементы данного массива умноженные 
на 2. Возвратите массив  a1_res. */

let a1 = [4, 5, 6, 7, 12, 34, 56, 78, 90, 11];

function t1() {
   let a1_res = a1.map(elem => {
      return elem * 2;
   });
   return a1_res;
}

document.querySelector('.b-1').onclick = () => {
   console.log(t1());
}

// Task 2 ============================================
/*  Дан массив a2= [2,3,4,5,10,11,12] - с помощью map переберите массив и создайте 
массив a2_res куда добавьте элементы данного массива возведенные во вторую степень. 
Возвратите массив a2_res. Действия должны запускаться при вызове функции t2.*/

let a2 = [2, 3, 4, 5, 10, 11, 12];

function t2() {
   let a2_res = a2.map(function (elem) {
      return elem ** 2;
   });
   return a2_res;
}

document.querySelector('.b-2').onclick = () => {
   console.log(t2());
}

//! Task 3 ============================================
/*  Дан массив a3 = [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите массив 
и создайте массив a3_res куда добавьте все элементы приведенные к числу. Возвратите a3_res.
Действия должны запускаться при вызове функции t3. */


let a3 = [4, "3", 6, 7, "12", 34, "56", 78, 90, 11];

function t3() {

   //    a3_res = a3.map(Number); // Переводит строку в число
   // return a3_res;

   let a3_res = a3.map(function (elem, index) {
      if (typeof elem == 'number') {
         return elem;
      }
   }).filter(function (i) {
      return !isNaN(i);
   });
   return a3_res;
}
document.querySelector('.b-3').onclick = () => {
   console.log(t3());
}


/*
Пример 1
function t3() {
    return a3.map(function (item) {
        return parseFloat(item);
    }).filter(i => !isNaN(i))
}

Пример 2
const t3 = arr => arr.map(parseFloat).filter(n => !Number.isNaN(n));
console.log(t3(a3));
*/
/*
isNaN
Аннотация
Функция isNaN() определяет является ли литерал или переменная нечисловым значением (NaN) 
или нет. При работе с функцией необходимо проявлять осторожность так как она имеет 
свои особенности. В качестве альтернативы можно использовать метод Number.isNaN() из 
ECMAScript 6, или дополнительно проверять литерал или переменную на нечисловое значение 
при помощи typeof.
Синтаксис
isNaN(значение)
Параметры
Значение
Литерал или переменная которые будут проверяться на нечисловое значение.
*/

/*
parseFloat()
Функция parseFloat() принимает строку в качестве аргумента и возвращает десятичное 
число (число с плавающей точкой)
Синтаксис
parseFloat(строка)
Параметры
строка
Текстовая строка, из которой вам надо выделить десятичное число.
Возвращаемое значение
Число с плавающей точкой, полученное из строки. Если первый символ не может быть 
сконвертирован в число, то возвращается NaN.

Описание
parseFloat - это высокоуровневая функция, не привязанная ни к одному объекту.

parseFloat разбирает текстовую строку, ищет и возвращает из неё десятичное число. 
Если функция встретит знак, отличный от (+ или -), цифр(0-9), разделительной точки, 
или показателя степени, она вернёт значение, предшествующее этому знаку, игнорируя 
все последующие символы . Допускаются позади и впереди идущие пробелы.

Если первый символ нельзя привести к числовому виду, parseFloat вернёт NaN.

С точки зрения математики, значение NaN не является числом в какой-либо системе счисления. 
Чтобы определить, вернёт ли parseFloat значение NaN в качестве результата, можно вызвать 
функцию isNaN. Если NaN участвует в арифметических операциях, результатом также будет NaN.

parseFloat также может вернуть значение Infinity ("бесконечность"). Вы можете использовать 
функцию isFinite, чтобы определить, является ли результат конечным 
числом (not Infinity, -Infinity, или NaN).
*/


//! Task 4 ============================================
/*  Следующая задача проще будет решаться через метод forEach, который мы изучим во 
второй части урока! Сейчас мы делаем костыль, для отработки навыков работы с map. 
Дан массив a4 = [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите массив и 
создайте массив a4_res куда добавьте ТОЛЬКО числа из массива a4. Возвратите a4_res. 
Действия должны запускаться при вызове функции t4. */

let a4 = [4, "3", 6, 7, "12", 34, "56", 78, 90, 11];

function t4() {
   let a4_res = a4.map(function (elem, index) {
      if (typeof elem == 'number') {
         return elem;
      }
   }).filter(function (i) {
      return !isNaN(i);
   });
   return a4_res;
}

document.querySelector('.b-4').onclick = () => {
   console.log(t4());
}

/*
Array.prototype.forEach()
Интерактивный пример
Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
Синтаксис
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
}[, thisArg]);
Параметры
callback
Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до 
трёх аргументов:
currentValue
Текущий обрабатываемый элемент в массиве.

Возвращаемое значение
undefined.

Описание
Метод forEach() выполняет функцию callback один раз для каждого элемента, находящегося 
в массиве в порядке возрастания. Она не будет вызвана для удалённых или пропущенных 
элементов массива. Однако, она будет вызвана для элементов, которые присутствуют 
в массиве и имеют значение undefined.

Функция callback будет вызвана с тремя аргументами:

значение элемента (value)
индекс элемента (index)
массив, по которому осуществляется проход (array)
*/



// Task 5 ============================================
/*  Дан массив b1 = [3, 14, 15, 92]. C помощью filter переберите массив и создайте 
b1_res, который содержит только четные числа из b1. Возвратите b1_res. 
Действия должны запускаться при вызове функции t5. */

let b1 = [3, 14, 15, 92];

function t5() {
   let b1_res = b1.filter(function (elem) {
      if (elem % 2 == 0) {
         return true;
      }
   });
   return b1_res;
}

document.querySelector('.b-5').onclick = () => {
   console.log(t5());
}

// Task 6 ============================================
/*  Дан массив b6 = [3, 14, 15, 92, "6", "5", "hello", 32]. C помощью filter переберите 
массив b6 и создайте массив b6_res, который содержит только числа из b6. Возвратите b6_res. 
Действия должны запускаться при вызове функции t6. */

let b6 = [3, 14, 15, 92, "6", "5", "hello", 32];

function t6() {
   let b6_res = b6.filter(function (elem) {
      if (typeof elem == 'number') {
         return true;
      }
   });
   return b6_res;
}

document.querySelector('.b-6').onclick = () => {
   console.log(t6());
}

// Task 7 ============================================
/*  Дан массив b7 = ["php-7", "html", "css", 92, "6", "5", "hello", 32]. C помощью 
filter переберите массив b7 и создайте  b7_res, который содержит только строки из b7, 
длина которых больше 3. Возвратите b7_res. Действия должны запускаться при вызове 
функции t7. */

let b7 = ["php-7", "html", "css", 92, "6", "5", "hello", 32];

function t7() {
   let b7_res = b7.filter(function (elem) {
      if (elem.length > 3 && typeof elem == 'string') {
         return true; // также можно и return elem;
      }
   });
   return b7_res;
}

document.querySelector('.b-7').onclick = () => {
   console.log(t7());
}

// Task 8 ============================================
/* Дан массив b8 = [3, 14, 15, 92, "6", "5", "hello", 32]. С помощью filter, переберите 
массив b8 и создайте массив b8_res, который содержит индексы четных элементов. 
Возвратите b8_res. Действия должны запускаться при вызове функции t8 */

let b8 = [3, 14, 15, 92, "6", "5", "hello", 32];

function t8() {
   let b8_res = [];
   b8.filter(function (elem, index) {
      if (elem % 2 == 0 && typeof elem == 'number') {
         b8_res.push(index);
      }
   });
   return b8_res;
}

document.querySelector('.b-8').onclick = () => {
   console.log(t8()); //  [1, 3, 7]
}

/*
Вар 1
let b8 = [3, 14, 15, 92, "6", "5", "hello", 32];

function t8(arr) {
  b8_res = [];
  
  arr.filter((num, index) => {
    if(Number.isInteger(num) && num % 2 === 0)
      b8_res.push(index);
  });
  
  return b8_res;
}

console.log(t8(b8)); //  [1, 3, 7]


Вар 2
b8.reduce((acc, el, index) => {
  if (Number.isInteger(el) && ((el & 1) === 0)) acc.push(index);
  return acc;
}, []);  // [1,3,7]
*/

// Task 9 ============================================
/*  Дан массив b9 = [3, "hello", 4, "world", 5, "hi"]. С помощью filter, переберите 
массив b9 и создайте массив b9_num и b9_string, которые содержат первый - числа из b9, 
второй - строки. Задачу решите с помощью filter. Действия должны запускаться при вызове 
функции t9. */

let b9 = [3, "hello", 4, "world", 5, "hi"];

function t9() {

   b9.filter(function (elem) {
      if (typeof elem == 'number') {
         b9_num.push(elem);
      } else if (typeof elem == 'string') {
         b9_string.push(elem);
      }
   });
   return [b9_num, b9_string];
}

document.querySelector('.b-9').onclick = () => {
   console.log(t9());
}


/*
function t9() {
    let b9 = [3, "hello", 4, "world", 5, "hi"];
    let out = b9.filter(item => {
        if (typeof item == 'string') {
            b9_string.push(item);
            return true;
        };
        if (typeof item == 'number') {
            b9_num.push(item);
            return true;
        };
    });
    document.querySelector('.out-9').innerHTML +='числа:'+ b9_num;
    document.querySelector('.out-9-2').innerHTML += 'строки:'+b9_string;
}

document.querySelector('.b-9').onclick = t9;
*/


//! Task 10 ============================================
/*  Дан массив b10 = [ [1,2,3], [3,4,6], [4,5,7], [8,9,3]]. С помощью filter переберите 
массив и создайте  b10_res, в который входят вложенные массивы содержащие цифру 3.  
Возвратите b10_res. Действия должны запускаться при вызове функции t10. */

// let b10 = [[1, 2, 3], [3, 4, 6], [4, 5, 7], [8, 9, 3]];

// function t10() {
//    let b10_res = b10.filter(function (elem) {
//       elem.filter(function (elem_1) {
//          return elem_1 == 3;
//       }).length;
//    });
//    return b10_res;
// }
// document.querySelector('.b-10').onclick = () => {
//    console.log(t10()); //[ [1,2,3], [3,4,6], [8,9,3]];
// }

// P.S. Вы же точно использовали переменные в начале файла? Не меняли область видимости?


let b10 = [[1, 2, 3], [3, 4, 6], [4, 5, 7], [8, 9, 3]];

function t10() {
   const b10_res = b10.filter(elem => elem.filter(el => el === 3).length);
   return b10_res;
}

document.querySelector('.b-10').onclick = () => {
   console.log(t10()); //[ [1,2,3], [3,4,6], [8,9,3]];
}