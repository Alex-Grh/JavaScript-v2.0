const a01 = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const b01 = ['a', 'b', 'c', 'd', 'e', 'f'];


//! Метод push() 
// Метод push позволяет добавить элементы в конец массива
// Метод push() добавляет один или более элементов в конец массива и возвращает новую длину массива.
// arr.push(element1, ..., elementN) - arr наш массив, метод push, может принимать несколько элементов (element1, ..., elementN)
// Что возвращает? Возвращает Новое значение свойства length объекта, для которого был вызван данный метод.

console.log(a01.length); // длинна массива 9

console.log(a01.push(10)); // добавим значение с помощью метода push
// такой вывод равняктся как
// let c = a.push(10);
// console.log(c);

// добавим несколько чисел
console.log(a01.push(11, 44, 55, 66));

console.log(a01); // выведим весь массив


// тоже самое будет с массивом b
// Метод push позволяет добавить элементы в конец массива
b01.push('j', 'e');
console.log(b01);


//! Метод pop() 
// Метод pop() удаляет последний элемент из массива и возвращает его значение.
// Метод pop удаляет последний элемент из массива и возвращает удалённое значение.
// Последний элемент массива или undefined, если массив пуст.
// arr.pop() - нету параметров это просто метод со скобочками
// Это все манипуляции в конце массива

const a02 = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const b02 = ['a', 'b', 'c', 'd', 'e', 'f'];
b02.pop(); // удаляет последний элемент = ['a', 'b', 'c', 'd', 'e'];
b02.pop(); // еще раз удаляет последний элемент = ['a', 'b', 'c', 'd';
console.log(b02);
console.log(b02.pop());
console.log(b02.pop());


//! Как удалить элемент внутри массива с помощью опе0ратора delete
const a03 = [1, 2, 3, 4, 5, 6, 7, 8, 9];
delete a03[3];
console.log(a03); // Появился пропуск под третим индексом empty (пустой)
// лучше неудалять массив а создать новый

//! Метод splice() (соединение)
// Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
// array.splice(start[, deleteCount[, item1[, item2[, ...]]]]) - start Индекс, по которому начинает изменять массив.
const b04 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'];

// Начинаем с 3 элемента 'd' (индекс 3 включительно) и заденим 2 элемента 'd' и 'e'
// Есть еще третий параметр добавление элемента. Удаляет и на его место ставит новый элемент 'hi'
b04.splice(3, 2, 'hi');

console.log(b04); // Таким образом метод splice() позволяет удалить массив и ерещитывать его индексы

//!! Существуют еще два опрератора shift и unshift которые позволяют удалять и добавлять элементы 
//! в начало массива
// Логика их действий идентичная операторам pop и push


//------------------------------------------------------------------------------------------------

// Task 1
// Есть массив d1, кнопка b-1, input i-1. Напишите функцию f1, которая при нажатии читает i-1 и 
// добавляем его в массив. После чего выводит массив в .out-1. Поскольку мы будем выводить 
// массив d1 неоднократно, то давайте вывод массива сделаем отдельной функцией, showArr - она 
// подготовлена. Изучите ее - это хороший способ оптимизировать код.

function showArr(domElem, arr) {
   let out = '';
   for (let i = 0; i < arr.length; i++) {
      out += arr[i] + ', ';
   }
   document.querySelector(domElem).innerHTML = out;
}

let d1 = [33, 'best', 66, 'best'];

function f1() {
   // ваш код здесь
   d1.push(document.querySelector(".i-1").value); // Метод push позволяет добавить элементы в конец массива
   console.log(d1); // Метод push позволяет добавить элементы в конец массива
   // ваш код здесь
   showArr('.out-1', d1);
}
document.querySelector('.b-1').onclick = f1;

// Task 2
//Напишите функцию f2, которая применяет метод pop к массиву d1, а затем выводит его (showArr) 
// в .out-2 функция выполняется при нажатии кнопки b-2

function f2() {
   d1.pop(); // Метод pop удаляет последний элемент из массива и возвращает удалённое значение.
   showArr('.out-2', d1);
}

document.querySelector('.b-2').onclick = f2;

// Task 3
// Напишите функцию f3, которая применяет метод shift к массиву d1, а затем выводит 
// его (showArr) в .out-3
// функция выполняется при нажатии кнопки b-3

function f3() {
   d1.shift(); // shift удаляет элемент вначале массива
   showArr('.out-3', d1);
}

document.querySelector('.b-3').onclick = f3;

// Task 4
// Напишите функцию f4, которая применяет метод push к массиву d1, данные для массива берите 
// из i-4, а затем выводит его (showArr) в .out-4
// функция выполняется при нажатии кнопки b-4


function f4() {
   d1.push(document.querySelector(".i-4").value); // Метод push позволяет добавить элементы в конец массива
   showArr('.out-4', d1);
}

document.querySelector('.b-4').onclick = f4;

// Task 5
// Напишите функцию f5, которая применяет метод unshift к массиву d1, данные для массива 
// берите из i-5, а затем выводит его (showArr) в .out-5
// функция выполняется при нажатии кнопки b-5

function f5() {
   d1.unshift(document.querySelector(".i-5").value); // unshift добавляет элемент вначале массива
   showArr('.out-5', d1);
}

document.querySelector('.b-5').onclick = f5;


// Task 6
// Напишите функцию f6, которая эмулирует работу метода push применительно к массиву d6. Т.е. 
// добавляет значение из i-6 как последний элемент в массив d6. Эмуляция, значит, что мы 
// получим результат аналогичный методу push без применения его. Эмуляция заключается в 
// присвоение значения как последнего элемента массива. Как вычислить индекс последнего 
// элемента используя длину массива - вы знаете из предыдущего урока. Повторный запуск 
// функции должен также приводить к добавлению элемента.
// Во всех задачах где говорим второй, третий и т.д. имеем ввиду индекс
// Вывод - по нажатию кнопки b-6
// Вывод в out-6

let d6 = ['test', 5, 12];

function f6() {
   d6[d6.length] = document.querySelector(".i-6").value;
   showArr('.out-6', d6);
}

document.querySelector('.b-6').onclick = f6;

// Task 7
// Напишите функцию f7, которая эмулирует метод pop, т.е. удаляет последний элемент массива d7. 
// Эмулировать - получать результат аналогичный pop, но без применения pop. Функция может быть 
// вызвана много раз, при этом каждый раз должен удаляться последний элемент d7.
// Во всех задачах где говорим второй, третий и т.д. имеем ввиду индекс
// Вывод - по нажатию кнопки b-7
// Вывод в out-7

let d7 = ['china', 'india', 'brazil', 'japan', 'egypt'];

function f7() {
   d7.length = d7.length - 1;
   showArr('.out-7', d7);
}

document.querySelector('.b-7').onclick = f7;


// Task 8
// Напишите функцию f8, которая эмулирует работу метода unShift - добавляем значение из i-8 
// в начало массива d8. Во всех задачах где говорим второй, третий и т.д. имеем ввиду индекс
// Вывод - по нажатию кнопки b-8
// Вывод в out-8

let d8 = [2, '4', 12, 67, 'hello'];

function f8() {
   // d8.unshift(document.querySelector(".i-8").value); // unshift добавляет элемент вначале массива
   // d8[0] = (document.querySelector(".i-8").value); // Меняет нулевой индекс d8[0] на (".i-8").value);
   let t8 = []; // создаем новую переменную с пустым массивом
   t8[0] = document.querySelector(".i-8").value; // задаем нулевой элемент как (".i-8").value; // значения вводит пользователь
   for (let i = 0; i < d8.length; i++) { // делаем перебор массива d8 от нуля let i = 0; по всей длинне до последнего элемента i < d8.length;
      t8[t8.length] = d8[i]; //! записываем в t8 последний элемент перебор из массива d8[i]. Нулевой элемент уже занят ...(".i-8").value; Получилось что после value добавили весь перебор с d8[i].
      //! Как работает длинна массива t8[t8.length] 
      //! индекс [0] для значения (".i-8").value, а длинна length массива 1
      //!t8[t8.length] здесь присваеваем значение не нулевому индексу а индексу [1] которого несуществует. Тоесть перезаписали тот индекс которого нет.
   }
   d8 = t8; // присваеваем в d8 значения с t8. Записан 0 элемент как ...(".i-8").value; и дальше весь перебор элементов с d8[i].
   console.log(d8) // Выводим d8 с добавленным первым элементом как (".i-8").value;
   showArr('.out-8', d8);
}

document.querySelector('.b-8').onclick = f8;

// Все просто посчитайте длину массива t8 перед началом цикла. Она равна 1 
// а если указать i переменную то она начинается с 0 так вас и получается затирание, 
// если хотите без t8[t8.length] то подставьте i+1. t8[i+1] = d8[i]

//! Объяснение как работает длинна массива t81[t81.length]
let t81 = []; // создаем новую переменную с пустым массивом
console.log(t81); // длинна массива 0
t81[0] = 'a'; // задаем нулевой элемент
console.log(t81); // индекс [0] для значения 'a', а длинна length массива 1
t81[t81.length] = "b"; // здесь присваеваем значение не нулевому индексу а индексу [1] которого несуществует. Тоесть перезаписали тот индекс которого нет.
console.log(t81); // индекс [0], [1], а длинна массива 2



// Task 9
// Напишите функцию f8, которая эмулирует работу метода shift - на примере массива d9.
// Во всех задачах где говорим второй, третий и т.д. имеем ввиду индекс
// Вывод - по нажатию кнопки b-9
// Вывод в out-9

let d9 = [100, 200, 300, 400, 700, 121];

function f9() {
   let p9 = [];
    for (let i = 1; i < d9.length; i++) {
       p9[i-1] = d9[i]
    }
    d9 = p9;
   showArr('.out-9', d9);
}

document.querySelector('.b-9').onclick = f9;

//! Как работает этот цикл https://qna.habr.com/q/695074
// let a = [4,5,6];
// function funcShift() {
//     let b = [];
//     for (let i = 1; i < a.length; i++) {
//        b[i-1] = a[i]
//     }
//     a = b;
//     document.querySelector('.out-8').innerHTML = a;
// }

// document.querySelector('.result-8').onclick = funcShift;

/*
Идём по массиву a до конца, начиная с элемента с индексом 1, в данном случае это 5-рка. 
Записываем эту пятёрку в массив b на первую(нулевую) позицию. Повторяем всё то же самое ещё 
одну итерацию. Таким образом получаем массив b = [5, 6].
Далее заменяем исходный массив a новым массивом b, в котором на один элемент у нас меньше. 
При следующем клике всё повторится и в массиве a станет на ещё один элемент меньше. 
Ребят, это очень просто.
*/

/*
1) у вас создается массив а с элементами 4, 5, 6
2) при запуске функции создается пустой массив b
3) запускается цикл от 1 до конца массива а (то есть, от второго до последнего элемента массива а)
4) но, благодаря [i-1], в массив b записываются элементы массива а со сдвигом 1 (то есть, b[0] = a[1], b[1] = a[2])
*/